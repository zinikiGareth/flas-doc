@Chapter
title=Declarations and Scopes


Within FLAS, many different types of concept can be defined; furthermore, the language is intended to be extensible so as to support additional concepts, in particular to support concepts internal to Ziniki.  Each of these concepts has its own declaration syntax and then supports specific nested content.  The details of these declaration types will constitute much of this manual.


However, these definitions can be broken down into "families" and an overview of these families will be discussed here.


Most definitions and nested declarations are introduced by a keyword or key operator; the exceptions are:


* when only one kind of declaration is allowed;
* function definitions.


@Comment


FLAS has been designed from the outset to be a "family" of languages.  The core of the language is the ability to express functional transformations from state to state in conformance with the actor model.  Anywhere that this model is applicable represents a potential target domain for FLAS.


In this regard, concepts like "cards" and "services" make sense in some contexts and not in others; more than that, in embedding FLAS in the Ziniki context, it is desirable to have more direct support for defining new concept types such as storable _entities_ with unique identifiers; _offers_ and _deals_ between parties and so on.  These are not part of the "core" language.


Similarly, other embedded uses offer other extensions to the core model, but in all cases the fundamental design of the language remains the same.
@/


&grammar rule='top-level-unit'
&review 'this should have all the ziniki defs in one block and we should remove that'
&grammar rule='top-level-definition'
&removeOption prod='entity-declaration'
&removeOption prod='deal-declaration'
&removeOption prod='offer-declaration'
&grammar rule='function-scope'
&grammar rule='function-scope-unit'


@Section
title=Functions


At heart, FLAS is a _functional_ language, and functions are core to data manipulation in FLAS.  As with most modern functional languages, FLAS functions are mathematically defined mappings from domains of values to a range of values.  While not perfectly mathematical, the use of lazy evaluation ensures that the operational semantics are close to the declared semantics.


The family of function declarations should be understood to include standalone and object _methods_ as well as event handlers and data callback handlers.


Depending on how the function is defined, the immediate nested members of this family may be conditional cases, which in turn introduces a scope where functions may be defined.  For simple functions, defined on one line, the immediate nesting level allows functions to be defined.


@Section
title=Data Types


The family of data type declarations includes $struct$, $union$ and $object$ definitions in core FLAS; Ziniki also defines $entity$, $envelope$, $deal$ and $offer$, along with the entity mapper declaration $wraps$.  The $state$ of $object$s and $card$s can be considered very similar.


For these types, the immediate nesting level defines fields.  Inner nesting levels allow constraints and metadata to be applied to the individual fields.


@Section
title=Contracts


Contracts define an abstract mechanism by which interactions between cards and services can be defined (similar to interfaces or protocols in other programming languages).  Because they are simple declarations, they are generally very simple.


One level of nesting is permitted to contracts to define the individual methods supported by the contract.


@Section
title=Actors


The family of actors includes $agent$s and $card$s on the client side and $service$s within microservice providers.


The top level of nesting within these definitions describes the individual elements that make up the overall definition.  These inner definitions are defined in the grammar.


Arbitrary function and standalone methods may also be included at the top level of nesting.
Each of these is defined using a series of block
Nested lines may be acceptable nested definitions; nested declarations must be introduced with a suitable keyword such as $state$, $template$ or $implements$.


@Section
title=Scoped Names


In order to ensure that names are globally unique, the _simple_ name of any definition is prefixed with the current scope name.


At the top level, the scope name is the package name.




@Comment


The source of test files ($.ut$, $.pt$ and $.st$ files) are collocated with the main ($.fl$) files.  However, they do not have individual names and instead are placed into test-specific sub-packages of the main package, each of which is given a name derived from the file name (e.g. __ut___file_).  Since the test cases themselves do not have names (just descriptions), the functions generated for these are given the names _ut0, _ut1 and so on. 


Placing the tests within separate packages (based on the file name) ensures the uniqueness of the overall name.  Using underscores in the package and test names ensures that they cannot clash with names defined with FLAS.  These names are never accessed externally but only by the test runner.
@/


Nested definitions use the enclosing definition name as the scope name.


@Comment


So, for example, if there is a simple $struct$ definition in package $test.my$:


$$
        struct Thing
                String name
$$


the $struct$ will be given the qualified name $test.my.Thing$ and the field $name$ will have the qualified name $test.my.Thing.name$.
@/


The simple name introduced in a scope must be unique and must not be defined in any enclosing definition.  
Function definitions may, however, be defined in multiple clauses at the same level provided such definitions are consecutive; this does not violate this rule because these clauses are combined to form a single definition.


@Comment


While this most obviously applies to function, type and actor names, it also applies to other names introduced into the scope such as parameter, field and type variable names.


For example, in the following definition, the parameter $x$ conflicts with the enclosed definition of $x$, creating an ambiguity and is therefore disallowed:


$$
        f x = y
                y = 2 * x
                        x = 14
$$


In the definition of $y$, which use of $x$ was intended?
@/