@Chapter
title=Methods
anchor=method-definitions


Methods are syntactic sugar for functions that map values to messages.


Methods may exist in a number of scopes and this determines how they are introduced.
&review 'ref all the places that this is true - standalone, event, implementation, handler'


In each case, the body of the method is the same.


&grammar rule='method-guards-or-actions'
&grammar rule='method-guards'
&grammar rule='method-guard'
&grammar rule='method-actions'
&grammar rule='method-action'
&grammar rule='message-method-action'
&grammar rule='service-method'
&grammar rule='maybe-handled'
&grammar rule='assign-method-action'


A method body consists of a set of actions which may be $SEND$ actions or $ASSIGN$ actions.  The order in which the actions appear is immaterial.


The set may be empty.


@Comment


In theory, the actions generated by a method, if executed, should be independent and idempotent.  This being the case, set semantics should be appropriate (duplicates are ignored and order is unimportant).  However, the real world is slightly more tricky than that.


As much as possible, FLAS will endeavour to enforce the set semantics and certainly will not honor the notion that ordering is important.  Errors will be issued for detected ambiguities. Since identifying all ambiguous programs perfectly is akin to the halting problem, it is not possible to fully detect all such programs.


However, ambiguous programs may produce inconsistent results.  The solution is to ensure that the program is unambiguous. 


How to achieve this is left as an exercise to the reader.
@/


@Section
title=Guards


Methods may be guarded.  Guards in methods work exactly as in functions (see &sp
&ref 'guarded-functions'
).


For guarded methods, all items in the nested block must be guards.  A guard consists of the $GUARD$ operator, optionally followed by a boolean expression.  All guards except the last must have a boolean expression.


As with functions, the guards will be examined and evaluated in turn and the first case which matches will be selected.  If there is a default case it will always be selected if examined.  If there is no default case and none of the expressions match an empty list of messages will be returned.


@Section
title=Sending Messages


Actions starting with the $SEND$ operator ($<-$) require an expression of type $Message$.  The value of the expression is added to the set of messages returned by the method.


@Comment


Remember that messages in FLAS are just _values_.  They are not acted upon until returned from a method to a message processing loop.  In the meantime they may be processed as ordinary values including being operated on by higher-order functions such as $map$ and $filter$.
@/


@Section
title=Updating State


Updating state is achieved by returning an $Assign$ message.


An $Assign$ message can be generated from within a method by writing the _slot_ to be assigned on the left of a $SEND$ operator ($<-$).  An assign message is created which identifies the _slot_ and the value on the right hand side of the operator.


@Comment


It is, of course, possible to directly return an $Assign$ message from a function or method.  Like everything else in methods, this is simply syntactic sugar which also provides name and type checking.
@/


A slot is a _dot expression_ that starts with a variable in scope and works through members of the current expression.


All state members are in scope.


Event handlers have the event object in scope.


Methods in $Handler$ definitions have the $Handler Lambda$ variables in scope.


Arguments to the method are in scope.


@Comment


In order for an assignment to be successful, the slot into which the value is to be assigned must be rooted in the state of the card or object.  Consequently, even though method arguments are in scope, they are unlikely to be reasonable targets for assignment.


Whenever the compiler can statically detect that an assignment will fail, it will issue an error.  Otherwise, the error will be detected at runtime and the assignment will fail, for all intents and purposes, silently.
@/


@Commentary


@Section
title=Messages


FLAS is a pure functional language wrapped in an actor model.  Each interaction represents a mapping from one system state to another, and this can be expressed as a set of messages.  During the evaluation of the interaction, _the actor state does not change_, no actor has access to the internal state of any other system component and the state of an actor never changes _except through an explicit interaction_.  In this way, the apparent state of an actor is always consistent and it is possible to reason logically about both the actor state and the overall system state.


FLAS can be considered to be _transactional_ in that the interaction either generates a set of messages or it does not, and then either all of those messages are consumed or none of them are.  Of course, it takes more than that to make a system truly transactional in an ACID sense


Messages are just values.  The $Message$ type is a $union$ consisting of various nested message types.  A function can create values of these types.


A method is simply a function that is called from a context in which it is possible to directly harness the messages being returned.  There are three such locations:


* within implementations of contracts inside actors;
* within the event handlers of cards or objects;
* within any existing method declaration.


Standalone methods are exactly syntactic sugar for moving between methods and functions and may only be called from other methods or functions.
&review 'ref to standalone methods'


@Section
title=Conflicts


It should not be possible to attempt to update the state of an object or actor inconsistently.  It should, however, be apparent that it is possible:


$$
object Obj
        state
                Number n <-0
        method wrong
                n <- 1
                n <- 2
$$


And, indeed, in this trivial case, it is easy to spot (even at compile time), but it is clear that there are more complex cases where more subtle conflicts can arise, including updating a value nested within a value which is removed from the actor state by another update.


It is anticipated that as time passes, the algorithm for detecting such conflicts (especially at compile time) will be improved, but in the meantime it is important to try and write code to minimize conflicts.